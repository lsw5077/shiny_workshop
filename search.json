{
  "articles": [
    {
      "path": "about.html",
      "title": "About the instructors",
      "author": [],
      "contents": "\r\n\r\n  .col2 {\r\n    columns: 2 200px;         /* number of columns and width in pixels*/\r\n    -webkit-columns: 2 200px; /* chrome, safari */\r\n    -moz-columns: 2 200px;    /* firefox */\r\n  }\r\n  .col3 {\r\n    columns: 3 100px;\r\n    -webkit-columns: 3 100px;\r\n    -moz-columns: 3 100px;\r\n  }\r\n\r\nDr. Denis Valle\r\n\r\n\r\n\r\n\r\n(drvalle@ufl.edu)\r\n\r\n\r\nDenis is a quantitative scientist broadly interested in problems in developing countries and Bayesian models. His work has focused predominantly in developing next-generation models for highly multivariate biodiversity data, determining the impact of large-scale anthropogenic stressors in the Amazon region, and developing models and decision support tools for malaria epidemiology.\r\n\r\n\r\nLyndsie Wszola, MS\r\n\r\n\r\n\r\n\r\n(lyndsie.wszola@huskers.unl.edu)\r\n\r\n\r\nLyndsie is a PhD student in the School of Biological Sciences and School of Natural Resources at the University of Nebraska Lincoln. Lyndsie’s work leverages large-scale fish and wildlife agency datasets to understand changing social and ecological dynamics of freshwater fisheries.\r\n\r\n\r\nChad Palmer\r\n\r\n\r\n\r\n\r\n(palmer.cr@ufl.edu)\r\n\r\n\r\nChad is a MS student at the University of Florida’s School of Forest Resources and Conservation. His past work has involved partnering with stakeholders to develop tools to help natural resource users communicate their regulatory preferences to resource managers.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:40:56-06:00"
    },
    {
      "path": "Activity_1.html",
      "title": "Activity 1: Interactive Maps",
      "author": [],
      "contents": "\r\nMany course participants are interested in displaying spatial information in the form of interactive maps. For this assignment, we have created a draft version of an app that displays the spatial distribution of the largest cities (from a population size perspective) across the world. This app relies on Leaflet, a package within R that can be used together with Shiny to generate these interactive maps.\r\nThe goal of this assignment is to improve this app. More specifically, we would like you to:\r\nAdd a title to this app\r\nAdd a drop down list to allow users to subset only the cities that belong to a particular country\r\nAdd a radio button that allow users to subset only the capital cities.\r\nCreate a side bar that will collect all the input that we want from the user (e.g., minimum population size and desired country)\r\nBonus challenge! If you get through the first four challenges, add the global May 2020 Normalized difference vegetation index raster file (NDVI_lite.tif) to the leaflet map to visualize global “greenness.” Visualize the variation in vegetation distribution using the r_colors palette created at the top of the script.\r\nDownload the attached .zip file and open assignment_map.R. Make the above changes and then check your answers against assignment_map_solution.R.\r\nLeaflet activity files\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:40:57-06:00"
    },
    {
      "path": "Activity_2.html",
      "title": "Activity 2: Group formation and Storyboard",
      "author": [],
      "contents": "\r\nGroup formation:\r\nOur goal is to create groups of course participants that have similar interests. To this end:\r\nWe ask that course participants provide a brief summary (max. 250 words) of the shiny app that they would like to develop as part of this course. Please post this summary, together with your name, stage, and affiliation in the top line of each project slot, in the following google document. You do not have to post a summary if you don’t have an idea for an app or if you believe that your idea is too undeveloped.\r\nAfter all summaries have been posted, people will be able to choose which group they would like to join. This will be done in the google document by people putting their names (and affiliation) below the author of the project they are interested in. The main restriction is that people can just join a single group and each group should have a maximum of 4 members.\r\nApp brainstorming:\r\nConceptual app development:\r\nParticipants will apply Structured Decision Making (SDM) to their own decision support tool. More specifically, working in small groups, participants will identify problems relevant to their work that can be informed by their model results using the storyboard. They will then map out how to use reactive elements and interactive visualization in conjunction with their model to facilitate the visualization of alternative decisions and their consequences as well as the identification of potential tradeoffs. Please remember that the envisioned app has to be simple enough so that it can be created within this course.\r\nHow to use the storyboard:\r\nAs you work through the pages of the storyboard, write or draw the scientific or communication problem your app addresses. Then plan out how you will use shiny widgets and reactive visuals to help your audience apply evidence to their decision-making process.\r\nStoryboard files\r\nActual app development (i.e., code development):\r\nAs time allows, participants will work on building a decision support interface around the model visualization they have already begun. To do this, people can keep working on group or start developing their own app. By the end of this module, participants will then present their work to the larger group and discuss how they are linking models, decision making frameworks, and code.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:40:58-06:00"
    },
    {
      "path": "Activity_3.html",
      "title": "A very crappie fish app",
      "author": [],
      "contents": "\r\nIt’s time to put our best practices to the test!\r\nDownload the Crappie fish app zip file and open the crappieFishApp/app.R. Run the app and examine the code. Discuss what the app does well and identify areas for improvement (there are a lot). The problems you identify could pertain to the app’s appearence, performance, accessibility, and the style and organization of the code. Consider the best practices we have suggested and your own wealth of coding knowledge.\r\nWork with your group to brainstorm solutions to the problems you have identified. Describe in detail the changes you would make and how they will improve the app’s form and function. Record the problems you have identified and the solutions you brainstormed in this google doc.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:40:59-06:00"
    },
    {
      "path": "Activity_4.html",
      "title": "Activity 4: App peer review",
      "author": [],
      "contents": "\r\nFeedback exchange:\r\nWe strongly believe in peer learning and we think that this is an excellent opportunity to learn from each other. The goal of this activity will be to provide and receive constructive feedback on each other’s app. Notice that this feedback can refer to the best practices we described earlier but does not have to be limited to these best practices. We would like each group to initially focus on the conceptual aspects of the app to then provide feedback into the actual code.\r\nOne way of doing this is to give everybody in the group 5 minutes to briefly present their app (or the idea for their app) while the other members of the group take notes. Once these presentations are over, then the group can go from app to app providing their comments in relation to the conceptual aspects of the app. On a second round, the group can go from app to app providing their comments regarding the code and how it is structured.\r\nPeer help:\r\nOnce the feedback exchange is over, you can use the remaining amount of time to provide or seek help from the other group members regarding your own app.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:40:59-06:00"
    },
    {
      "path": "index.html",
      "title": "Welcome to the SESYNC Decision Support Tool Short Course!",
      "author": [],
      "contents": "\r\nThe class combines pre-recorded lectures on topics including shiny workflows and decision processes with live discussions and supported time to work on projects. Check out the “Module” tabs for the course material and zoom links and the “Resources” tab for shiny examples, tutorials, and reading about other decision, programming, and modeling topics. Instructor bios and contact information can be found on the “About” tab.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:00-06:00"
    },
    {
      "path": "mod0.html",
      "title": "Module 0: Before we begin",
      "author": [],
      "contents": "\r\nPreparation\r\nWelcome everyone! Before we get going, let’s make sure we have all the tools we need before the course starts. First and foremost, make sure you have the most recent versions of R and RStudio.\r\nNext, let’s install all the packages we’re going to need. Copy and paste this code into a new script or your RStudio console and run it.\r\n\r\n\r\n# Install packages hosted on cran\r\n\r\ninstall.packages(c(\"tidyverse\",\r\n                   \"shiny\",\r\n                   \"leaflet\",\r\n                   \"remotes\",\r\n                   \"rfishbase\",\r\n                   \"viridis\",\r\n                   \"shinydashboard\",\r\n                   \"rgdal\",\r\n                   \"raster\",\r\n                   \"sp\",\r\n                   \"maps\"))\r\n\r\n# install the wingspan data package from github\r\n\r\nremotes::install_github('coolbutuseless/wingspan')\r\n\r\n# install the colorblindr package from github for accessibility testing\r\n\r\nremotes::install_github('clauswilke/colorblindr')\r\n\r\n\r\n\r\nIf all of that ran and your packages are installed, we’re good to go! If not, let one of us know and we’ll help you out.\r\nCourse organization\r\nThis course consists of 5 morning blocks spread throughout 5 weeks. The first 4 morning blocks will be organized in the following way:\r\n\r\n\r\nTime\r\n\r\n\r\nDescription\r\n\r\n\r\nPrior to event\r\n\r\n\r\nWatch pre-recorded lectures/coding sessions (these videos are available in the corresponding module link)\r\n\r\n\r\n08:30-10:30 EST\r\n\r\n\r\nGroup activity\r\n\r\n\r\n10:30-11:30 EST\r\n\r\n\r\nWrap-up session\r\n\r\n\r\nThe last morning block will be used for participants to present the apps they have developed as part of this course.\r\nDuring the group activities, we expect that all course participants will fully engage and participate in the different activities. More specifically, we request that participants treat virtual meetings the same they would have if they were traveling to Annapolis (e.g., block off the morning period, set an out-of-office email for the day, etc.). Furthermore, at the start of each activity, we strongly encourage everybody to keep their cameras on and avoid checking emails.\r\nDuring the wrap-up session, we will summarize the main topic of the day and clarify the most common sources of confusion. This session will provide closure to the activities of the day and will help prepare participants for the activities in the following week.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:01-06:00"
    },
    {
      "path": "mod1.html",
      "title": "Module 1: Introductions and Shiny basics (02-02-2021)",
      "author": [],
      "contents": "\r\n\r\nUpon completion of this module, learners should be able to:\r\nExplain the basic structure and components of a script to create a shiny app\r\nDistinguish the features that are part of the user interface (UI) and the features that are part of the server.\r\nList and select the most appropriate shiny function for the desired user input\r\nDescribe how the interactive display of data and/or model results can be useful for policy\r\n\r\n\r\n\r\nIntroduction to web-based tools (Denis)\r\nInteractive display of model results for policy: context for app (Denis)\r\nInteractive display of model results for policy: code for app (Denis)\r\nBurkina Faso tool\r\nBurkina Faso code\r\n\r\nShiny basics: interactive data display (Lyndsie)\r\nVideo tutorial 1\r\nVideo tutorial 2\r\nExample App: Loblolly\r\n\r\nBonus! Cool shiny functions (Chad)\r\nActivity 1: Leaflet map\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:03-06:00"
    },
    {
      "path": "mod2.html",
      "title": "Module 2: From models to policy (02-09-2021)",
      "author": [],
      "contents": "\r\n\r\nUpon completion of this module, learners should be able to:\r\nExplain and apply the main steps in structured decision making\r\nExplain the interplay between statistical models and decision support tools and develop statistical models specifically tailored to the intended decision support tools\r\n\r\n\r\n\r\nIntro to Structured Decision Making (Lyndsie)\r\nOptional Reading: Humpback chub structured decision making\r\n\r\nFrom Models to Policy (Denis)\r\nMSAT vs MDA example app\r\nMSAT vs MDA code\r\n\r\nActivity 2: App brainstorming\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:04-06:00"
    },
    {
      "path": "mod3.html",
      "title": "Module 3: Enabling value-based parameters (02-16-2021)",
      "author": [],
      "contents": "\r\n\r\nUpon completion of this module, learners should be able to:\r\nDescribe how interactive web applications can enable the use of value-based parameters and how these parameters are critical to solve “wicked” problems\r\nDescribe and use R best practices\r\nDescribe and use Shiny-specific best practices\r\n\r\n\r\n\r\nValue-based parameters: a road routing example (Denis)\r\nRoad routing app\r\nRoad routing code\r\n\r\nBest practices (Lyndsie + class discussion)\r\nBasic R best practices\r\nShiny-specific Best practices\r\n\r\nActivity 3: A very crappie fish app\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:04-06:00"
    },
    {
      "path": "mod4.html",
      "title": "Module 4: The importance of user experience (February 23, 2021)",
      "author": [],
      "contents": "\r\n\r\nUpon completion of this module, learners should be able to:\r\nExplain what is collaborative tool development and why it is important\r\nIllustrate the iterative process of creating an interactive web application\r\nExplain the main options for shiny hosting and for long-term app maintenance\r\n\r\n\r\n\r\nOyster example and usability (Chad)\r\nPheasant management app and collaborative tool development (Lyndsie)\r\nExample App: Pheasant habitat simulator\r\n\r\nShiny hosting and long-term maintenance (Lyndsie)\r\nActivity 4: Peer review\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:05-06:00"
    },
    {
      "path": "mod5.html",
      "title": "Module 5: Presentations (March 3, 2021)",
      "author": [],
      "contents": "\r\n\r\nUpon completion of this module, learners should be able to:\r\nPrepare a prototype of an interactive web application focused on their own work hosted on shinyapps.io\r\nDescribe a wide range of uses for interactive web applications\r\nUpon completion of this course, we hope that learners will have had the opportunity to interact with several of the other course participants, ultimately having developed a network of peer Shiny app developers\r\n\r\n\r\n\r\nFor this module, we would like for each person or group to present their app. It is fine if the app is not up and running. In this case, course participants should describe how the app would look like and what would be its main features.\r\nWhen presenting their app, we would like participants to follow the Structured Decision Making framework when making their presentation.\r\nFurthermore, it would be great if participants emphasized the best practices that they attempted to follow/implement. When presenting your app, make sure your app is hosted on shinyapps.io so that we can practice the whole workflow, even if there pieces that need to be improved. This is partly to make sure that we have provided all the information that you need so that you can put your app online without a problem.\r\nFinally, please note that each presentation will be limited to 10 minutes to give enough time for everybody to present their app.\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:05-06:00"
    },
    {
      "path": "RBestPractices.html",
      "title": "Some best practices",
      "description": "Any fool can write code that a computer can understand. Good programmers write code that humans can understand. -- Martin Fowler, 2008.",
      "author": [],
      "contents": "\r\nThe purpose of this tutorial is to illustrate R best practices that facilitate efficient Shiny app development and debugging. All of these best practices pertain to writing R code in general beyond Shiny apps. We bring them up as part of the Shiny course because Shiny apps have many moving parts. Keeping our code as human-readable, automated, and compartmentalized as possible will help us spend less of our time debugging and more of our time communicating science.\r\nBefore we begin\r\nIf we’re going to chat about a dry subject like optimizing code, we might as well have a little fun. If you want to code along with this tutorial, you’ll need the wingspan package, which contains data from the delightful wingspan board game, wherein you win points through various bird-related challenges. We’ll also need the colorblinr package for some accessibility testing and the remotes package to install wingspan and colorblindr from github. In addition, we’ll need the tidyverse package, so go ahead and install that too if you haven’t already.\r\n\r\n\r\n\r\nNaming conventions\r\nWhen choosing names for data, we have to balance the needs to be concise, descriptive, and consistent. Let’s assume we want to make two dataframes, one containing information on platform-nesting birds, and one containing information on cavity-nesting birds. We could name our two dataframes Data1 and data_2.\r\nWe’ll create our dataframes using the filter() function from the dplyr package, which comes as a part of the tidyverse. filter() keeps only rows that match the conditions in the parentheses, here that nest_type equals “Platform” and “Cavity,” respectively. The %>% is called a “pipe,” and it essentially means “take everything from the left side of the pipe and apply this series of operations to it.” It saves us from having to make a new data frame each time we want to apply a new function or calculation.\r\n\r\n\r\nbirds <- wingspan::birds\r\n\r\n\r\nData1 <- birds %>% filter(nest_type == \"Platform\")\r\ndata_2 <- birds %>% filter(nest_type == \"Cavity\")\r\n\r\n\r\n\r\nThese names are concise and they work just fine from the computer’s perspective. However, it will be easier for us as humans to organize our code and our thoughts if our data structures and modeling components follow one framework for naming. Some popular frameworks include camelCase/CamelCase where we use capital letters to mark breaks between words or snake_case where we use underscores to separate words. Since we’re focusing on human readability, you should go with whatever format works for you as long as you use it to build a consistent naming convention. The Advanced R book suggests using lower-case nouns for variables and dataframes, so that’s what we’ll do here:\r\n\r\n\r\nbirds <- wingspan::birds\r\ndata_1 <- birds %>% filter(nest_type == \"Platform\")\r\ndata_2 <- birds %>% filter(nest_type == \"Cavity\")\r\n\r\n\r\n\r\nNow our names are concise and follow a similar style, but they’re not terribly descriptive. This might be fine if we just have one or two dataframes, but having lots of similarly-named dataframes can make it hard for us to keep our data straight later when we start building more complex data structures or when we hand off the project to someone else. Let’s give our dataframes some more descriptive names reflecting their content:\r\n\r\n\r\nbirds <- wingspan::birds\r\nplatform_nesters <- birds %>% filter(nest_type == \"Platform\")\r\ncavity_nesters <- birds %>% filter(nest_type == \"Cavity\")\r\n\r\n\r\n\r\nComments\r\nAt this point, our code making a dataframe of platform-nesting bird data and a dataframe of cavity-nesting bird data is nice and clear. To us. Today. But what if we want to share it with someone who didn’t get our lovely introduction above? Or what if we need to put it down for a few months (life happens) and pick it up later?\r\nOne of the kindest things we can do for ourselves is to liberally annotate our code with comments. A good comment can accomplish many things. It can include useful metadata and information on the code developers. Crucially, comments also give us a way to track dependencies, changes, and developments in our code so we can save time debugging when things go wrong later. Especially important to us as scientists, we can use comments to record our objectives and explain how our code meets them.\r\n\r\n\r\n# Make a dataframe of platform nesters and a dataframe of cavity nesters\r\n# using the birds data from the wingspan package and the filter()\r\n# function from the dplyr package.\r\n\r\nbirds <- wingspan::birds\r\nplatform_nesters <- birds %>% filter(nest_type == \"Platform\")\r\ncavity_nesters <- birds %>% filter(nest_type == \"Cavity\")\r\n\r\n\r\n\r\nText wrapping and visual layouts\r\nIn addition to supplementing our code with abundant, descriptive comments, we can make our coding lives much easier with some strategic text wrapping and visual layouts. One of the nice things about R is that we can arrange our code with line breaks and spacing to make it easy to read and scan for mistakes. Let’s update our code using the select() function from the dplyr package to select several columns. If we keep everything on one line like we did above, it quickly gets overwhelming (note our new comment reflecting our update!):\r\n\r\n\r\n# Make a dataframe of platform nesters and a dataframe of cavity nesters\r\n# using the birds data from the wingspan package and the filter()\r\n# function from the dplyr package.\r\n\r\n# Update: added select function to select several columns\r\nbirds <- wingspan::birds\r\nplatform_nesters <- birds %>% filter(nest_type == \"Platform\") %>% select(common_name, scientific_name, nest_type, egg_capacity, wingspan, forest, grassland, wetland, invertebrate, seed, fish, fruit, rodent, nectar, any_food)\r\ncavity_nesters <- birds %>% filter(nest_type == \"Cavity\")%>% select(common_name, scientific_name, nest_type, egg_capacity, wingspan, forest, grassland, wetland, invertebrate, seed, fish, fruit, rodent, nectar, any_food)\r\n\r\n\r\n\r\nBreaking up our code over several lines at the pipes %>% and commas between selected columns gives us a much cleaner code block that’s easier to navigate. Advanced R recommends limiting lines to 80 characters or fewer as a rule of thumb. From here forward, we’ll use the platform_nesters and cavity_nesters dataframes and add on to them.\r\n\r\n\r\n# Make a dataframe of platform nesters and a dataframe of cavity nesters\r\n# using the birds data from the wingspan package and the filter()\r\n# function from the dplyr package.\r\n\r\n# Update: added select function to select several columns\r\n\r\nbirds <- wingspan::birds\r\n\r\nplatform_nesters <- birds %>%\r\n                    filter(nest_type == \"Platform\") %>% \r\n                    select(common_name,\r\n                           scientific_name,\r\n                           nest_type,\r\n                           egg_capacity,\r\n                           wingspan,\r\n                           forest,\r\n                           grassland,\r\n                           wetland,\r\n                           invertebrate,\r\n                           seed,\r\n                           fish,\r\n                           fruit,\r\n                           rodent,\r\n                           nectar,\r\n                           any_food)\r\n\r\n\r\ncavity_nesters <- birds %>%\r\n                  filter(nest_type == \"Cavity\")%>% \r\n                  select(common_name,\r\n                         scientific_name,\r\n                         nest_type,\r\n                         egg_capacity,\r\n                         wingspan,\r\n                         forest,\r\n                         grassland,\r\n                         wetland,\r\n                         invertebrate,\r\n                         seed,\r\n                         fish,\r\n                         fruit,\r\n                         rodent,\r\n                         nectar,\r\n                         any_food)\r\n\r\n\r\n\r\nFunctions\r\nAs soon as we progress beyond very basic operations in R, we’ll find ourselves having to do the same operation multiple times. Functions allow us to automate these kinds of repetitive tasks. Let’s say we really want to win at wingspan by collecting the most eggs possible. Given that food is a limited resource in the game, we might want to play the birds with the highest return of eggs per unit food item. We can update our code blocks to give us only birds above a critical efficiency threshold, let’s say 3 eggs per food item. We won’t save our observations just yet. Instead, we’ll select a few columns to look at and just print the dataframes.\r\n\r\n\r\n              platform_nesters %>% \r\n                    mutate(egg_efficiency = # calculate return of eggs/ unit food\r\n                           egg_capacity/\r\n                           (seed + fish +\r\n                            fruit + rodent +\r\n                            nectar + any_food)) %>%\r\n                    arrange(desc(egg_efficiency)) %>% # arrange in descending order\r\n                    select(common_name, egg_efficiency) %>%\r\n                    filter(egg_efficiency >= 3) # keep only birds with efficiency >= 3\r\n\r\n\r\n# A tibble: 10 x 2\r\n   common_name           egg_efficiency\r\n   <chr>                          <dbl>\r\n 1 Griffon Vulture                  Inf\r\n 2 Mourning Dove                      5\r\n 3 Ruddy Duck                         5\r\n 4 Crested Pigeon                     4\r\n 5 Peaceful Dove                      4\r\n 6 Pied-Billed Grebe                  4\r\n 7 Common Little Bittern              3\r\n 8 Eurasian Magpie                    3\r\n 9 Green Heron                        3\r\n10 King Rail                          3\r\n\r\n                cavity_nesters %>% \r\n                    mutate(egg_efficiency = # calculate return of eggs/ unit food\r\n                           egg_capacity/\r\n                           (seed + fish +\r\n                            fruit + rodent +\r\n                            nectar + any_food)) %>%\r\n                    arrange(desc(egg_efficiency)) %>% # arrange in descending order\r\n                    select(common_name, egg_efficiency) %>%\r\n                    filter(egg_efficiency >= 3) # keep only birds with efficiency >= 3\r\n\r\n\r\n# A tibble: 39 x 2\r\n   common_name          egg_efficiency\r\n   <chr>                         <dbl>\r\n 1 Black Vulture                   Inf\r\n 2 Common Swift                    Inf\r\n 3 European Bee-Eater              Inf\r\n 4 House Wren                      Inf\r\n 5 Purple Martin                   Inf\r\n 6 Turkey Vulture                  Inf\r\n 7 Vaux's Swift                    Inf\r\n 8 Violet-Green Swallow            Inf\r\n 9 White-Throated Swift            Inf\r\n10 Coal Tit                          6\r\n# ... with 29 more rows\r\n\r\nAgain, this works fine. BUT, there’s no reason for us to do the same work twice. Instead, let’s write a function that lets us calculate egg efficiency and retain only birds with egg efficiency above a threshold. This will work exactly like any other R function like mean() etc. We just have to write out our summary code as we did above, substituting flexible argument names, and then run the function in the console. This is called “sourcing.” When we source a function, it should appear in our environment pane. Once we source our new function, called calc_egg_eff, using lower-case verbs as suggested by Advanced R, we’ll just print the dataframes to inspect them rather than saving them to new objects.\r\n\r\n\r\n# Writing a function to calculate egg efficiency and keep only birds above a critical\r\n# egg efficiency value\r\n\r\ncalc_egg_eff <- function(bird_df, # function arguments with no defaults. Bird dataframe\r\n                         egg_threshold){ # work just like any other function. Critical egg threshold.\r\n  \r\n  \r\n  bird_df <- bird_df %>%\r\n             mutate(egg_efficiency = # calculate return of eggs/ unit food\r\n                    egg_capacity/\r\n                    (seed + fish +\r\n                     fruit + rodent +\r\n                     nectar + any_food)) %>%\r\n                     arrange(desc(egg_efficiency)) %>% # arrange in descending order\r\n                     select(common_name, egg_efficiency) %>%\r\n                     filter(egg_efficiency >= egg_threshold)\r\n  \r\n  # what to return when the function is called.\r\n  \r\n  return(bird_df)\r\n  \r\n  }\r\n\r\n# make a summary dataframe of platform nesters including only birds with egg efficiency greater than 3.\r\n\r\n          calc_egg_eff(bird_df = platform_nesters,\r\n                       egg_threshold = 3)  # keep only birds with efficiency >= 3\r\n\r\n\r\n# A tibble: 10 x 2\r\n   common_name           egg_efficiency\r\n   <chr>                          <dbl>\r\n 1 Griffon Vulture                  Inf\r\n 2 Mourning Dove                      5\r\n 3 Ruddy Duck                         5\r\n 4 Crested Pigeon                     4\r\n 5 Peaceful Dove                      4\r\n 6 Pied-Billed Grebe                  4\r\n 7 Common Little Bittern              3\r\n 8 Eurasian Magpie                    3\r\n 9 Green Heron                        3\r\n10 King Rail                          3\r\n\r\n# And make a summary dataframe for cavity nesters\r\n\r\n          calc_egg_eff(bird_df = cavity_nesters,\r\n                       egg_threshold = 3) \r\n\r\n\r\n# A tibble: 39 x 2\r\n   common_name          egg_efficiency\r\n   <chr>                         <dbl>\r\n 1 Black Vulture                   Inf\r\n 2 Common Swift                    Inf\r\n 3 European Bee-Eater              Inf\r\n 4 House Wren                      Inf\r\n 5 Purple Martin                   Inf\r\n 6 Turkey Vulture                  Inf\r\n 7 Vaux's Swift                    Inf\r\n 8 Violet-Green Swallow            Inf\r\n 9 White-Throated Swift            Inf\r\n10 Coal Tit                          6\r\n# ... with 29 more rows\r\n\r\nMuch cleaner! If you want to take developing your own functions a step further (your should!), you can write all your functions in a seperate script and source it or write your own R package. It’s easier than you might expect!. For right now, we’ll just write ourselves one egg efficiency function and appreciate our cleaned-up code. I could say a lot more about function development that I will leave out here for the sake of simplicity, but I absolutely encourage you to check out R for Data Science and Advanced R.\r\nAccessibility\r\nBest practices for R graphics take up entire books. We’re just going to touch briefly on graphics here to provide some guidance for accessibility. Specifically, we’ll deal with making graphics color-blind safe. We’ll talk more about accessibility in the Shiny-specific Best Practices section.\r\nFirst, let’s address colors. Color can be an important tool for data visualization, but we need to make sure our great colors are actually interpretable to everyone. Colors are composed of hues (the slice of the color wheel a color occupies) and value (the ammount of black in the color). By choosing colors that contrast values as well as hues, we can make sure that color-blind audience members can interpret our visuals. To see the impact of using hues and values strategically in practice, let’s make a plot of some of our wingspan data using the ggplot package. Using ggplot(), we’ll make a scatter plot with birds’ wingspan on the x axis and victory points on the y axis, with color determined by whether or not a bird is a predator via the scale_color_manual() function.\r\n\r\n\r\n# Make a scatter plot called victory_point\r\n# displaying wingspan on the x axis and victory points on the y axis\r\n# Make non-predators dark red and predators green\r\n\r\nvictory_plot <- ggplot(birds) +\r\n                 geom_point(aes(x = wingspan,\r\n                                y = victory_points, \r\n                                color = predator),\r\n                            size = 3) +\r\n                 scale_color_manual(values = c(\"FALSE\" = \"darkred\",\r\n                                    \"TRUE\" = \"darkgreen\")) +\r\n                 theme_bw()\r\n\r\n# print victory_plot\r\n\r\nvictory_plot\r\n\r\n\r\n\r\n\r\nAssuming you’re not colorblind, this plot looks ok. Now we’ll use the cvd_grid() function from the colorblindr package to simulate what the plot would look like to people with different forms of colorblindness.\r\n\r\n\r\n# Simulate what victory_plot would look like to people with different\r\n# kinds of color blindness.\r\n\r\ncvd_grid(victory_plot)\r\n\r\n\r\n\r\n# Hard to distinguish between predators and non-predators.\r\n\r\n\r\n\r\nIt’s much harder to distinguish the difference between predators and non-predators! That’s because even though the darkred and darkgreen colors have different hues, they have similar values. Let’s try distinguishing between predators and non-predators using colors that differ in value as well as hue. We’ll call our revised plot victory_plot_cbf for “colorblind friendly.”\r\n\r\n\r\n# Make a scatter plot called victory_point\r\n# displaying wingspan on the x axis and victory points on the y axis\r\n# Make non-predators light blue and predators dark green\r\n\r\nvictory_plot_cbf <- ggplot(birds) +\r\n                 geom_point(aes(x = wingspan,\r\n                                y = victory_points, \r\n                                color = predator),\r\n                                size = 3) +\r\n                 scale_color_manual(values = c(\"FALSE\" = \"#67a9cf\",\r\n                                    \"TRUE\" = \"#016c59\")) +\r\n                 theme_bw()\r\n\r\n# print victory_plot\r\n\r\nvictory_plot_cbf\r\n\r\n\r\n\r\n# Simulate what victory_plot would look like to people with different\r\n# kinds of color blindness.\r\n\r\ncvd_grid(victory_plot_cbf)\r\n\r\n\r\n\r\n# Much more colorblind friendly!\r\n\r\n\r\n\r\nOur revised plot is much easier to interpret! We retain contrast when we simulate what our plot would look like to people with different kinds of color-blindness. If you want to try different combinations of colorblind-friendly colors, check out color brewer\r\nDisclaimer:\r\nLike many ecologists who write R code, I am largely self-taught. Some of my style choices will therefore be different than what you might see if you read source code and recommendations from an actual software engineer because I’m still learning too. There is also a lot more to writing R code that “smells and feels good,” as Jenny Bryan would say, than we’ve covered in this quick and dirty introduction.\r\nThese best practices are based on the Advanced R and R for Data Science books. If you want more exposure to best practices from the experts, I would absolutely check out those books, as well as recorded plenary talks from conferences like UseR and Rstudio::conf.\r\nArticle by Lyndsie Wszola\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:11-06:00"
    },
    {
      "path": "resources.html",
      "title": "Resources",
      "author": [],
      "contents": "\r\nOther example apps in Ecology, Conservation, and Epidemiology\r\nRecovery Prioritization Explorer\r\nInfectious disease emergence and economics of altered landscapes\r\nOther Shiny and R programming Resources\r\nThe Shiny gallery\r\nMastering Shiny book\r\nR for data science\r\nAdvanced R\r\nThe unofficial solutions manual to R for data science\r\nThe R graphics cookbook\r\nThe Shiny cheatsheet\r\nThe data wrangling cheatsheet\r\nThe ggplot cheatsheet\r\nThe Rmarkdown cheatsheet\r\nThe lubridate cheatsheet\r\nStats and modeling resources\r\nBen Bolker’s statistical modeling book\r\nSESYNC Bayesian course\r\nTidymodels\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:12-06:00"
    },
    {
      "path": "shinyBasics.html",
      "title": "Shiny Basics",
      "author": [],
      "contents": "\r\nWelcome to Shiny basics, in which we make our first app!\r\nCode our first shiny app\r\nLearn about the parts of a shiny app (ui and server)\r\nBuild a basic understanding of shiny reactivity.\r\nYou can follow this tutorial however suits your needs best. It goes with this video of me coding the app “live” from scratch. You can also follow along using the app.R file located in this folder if you’d rather look at the finished product as we describe its components.\r\nBefore we begin\r\nBefore we get going on our app, we need to pause and make sure we all have the right software installed. We’ll need the latest versions of R and RStudio installed on our computers. The only R package we need for this tutorial is shiny itself. If you don’t have shiny installed yet, open an RStudio window. In the console type:\r\n\r\n\r\ninstall.packages(\"shiny\")\r\n\r\n\r\n\r\nShiny is a big package, so don’t worry if it takes a moment to install. If shiny installs properly for you and you can load it properly by running library(shiny) in a script or in the console, continue to the next step. If you have difficulties installing or loading shiny, let one of us know ASAP and we’ll help you get it figured out. Ready to dive in? Great! Let’s make a plot!\r\nLet’s make a plot\r\nOur example shiny app will use one of R’s built-in datasets, Loblolly. Loblolly records height at age of Loblolly pine trees over the course of their lives. Let’s take a quick peak at the data:\r\n\r\n\r\nhead(Loblolly)\r\n\r\n\r\n   height age Seed\r\n1    4.51   3  301\r\n15  10.89   5  301\r\n29  28.72  10  301\r\n43  41.74  15  301\r\n57  52.70  20  301\r\n71  60.92  25  301\r\n\r\nRight away, we see some information about tree age, in the “age” variable and tree height in the “height” variable. I’m going to assume age is in units of years and height is in units of feet (sorry) since Loblolly pines are native to the Southeastern United States. A scattern plot displaying height as a function of age seems like a natural way to visualize this data, so that’s what we’ll do!\r\n\r\n\r\n   plot(Loblolly$age,  # age on the x axis\r\n        Loblolly$height, # and height on the y\r\n   xlab = \"Age (Years)\", # Let's add some axis labels\r\n   ylab = \"Height (Feet)\")\r\n\r\n\r\n\r\n\r\nOur plot shows that trees get taller over time (yay!). What if we’re working with a decision-maker who wants to visualize growth of trees in ages 10 and younger? We could subset our data to include only trees under the age of 10 and then remake the plot:\r\n\r\n\r\n # We subset our data to trees 10 or younger       \r\n                                \r\n   LoblollySmall <- Loblolly[Loblolly$age <= 10,]\r\n       \r\n   # Then make our plot as before!\r\n   \r\n   plot(LoblollySmall$age, LoblollySmall$height,\r\n   xlab = \"Age (Years)\",\r\n   ylab = \"Height (Feet)\")\r\n\r\n\r\n\r\n\r\nThis works just fine, but if our decision-maker isn’t an R expert, they have to ask us for a different plot each time they want to look at a new age range. This is not a good use of anyone’s time. So:\r\nLet’s make an app!\r\nThis is the point where watching me do this in the recorded video lesson will be quite helpful if you’re totally new to shiny apps. Not only will you get my verbal explanations of what’s happening, but you also get to watch me make (hopefully informative) mistakes, which gives you a better idea of how the app development process goes.\r\nBefore we start coding our app, we need a safe place for it to live. Open RStudio and make yourself a new folder on your computer somewhere that will be easy to find and remember using the dir.create() function typing directly in the console. My new directory is located in the directory where I’m building this workshop website (using the distill package, btw). It doesn’t matter where yours is located, as long as we can find it again in a minute.\r\n\r\n\r\ndir.create(\"C:/Users/Lyndsie/Documents/GitHub/shiny_workshop/exampleApps\")\r\n\r\n\r\n\r\nTo start a new shiny app, we’ll open RStudio and click File>New File>Shiny Web App.\r\n\r\nIn the new shiny web application dialog box, we’re prompted to choose a name for our app. We’ll call it “Loblolly” and ititate it as a single file app using the radio selector buttons. We’re also given the option to place our new app in an existing directory. Click “browse” and navigate to the directory we created using dir.create() and initiate our app by clicking “Create.”\r\n\r\nIf we look in ~/exampleApps the directory that we created earlier, we now see a folder called “Loblolly/” containing one file, “app.R”\r\n\r\nNew shiny apps initiate with a great example app provided by the folks at RStudio using the “Old Faithful” sample dataset. The app consists of a slider that lets us selecthte number of bins in a histogram. Let’s pause briefly to play with the example app a bit. Click the “Run App” button and experiment with the slider.\r\n\r\nOnce you’ve satisfied your curiosity a little, close the browser window and delete all the code in app.R so we have a blank script. Don’t worry. We won’t break anything and it will work better for us to learn by building our app up from scratch.\r\n\r\nGetting started\r\nWe’ll start setting up our app by loading the shiny library outside the app code itself. We put these lines outside the main app code so they’re run just once, which reduces memory needs and run time.\r\n\r\n\r\n# Load libraries and do other one-time tasks outside main app code.\r\n\r\nlibrary(shiny)\r\n\r\n\r\n\r\nBasic app structure\r\nShiny apps are built in two pieces: the user interface and server. The user interface (ui), as the name suggests, creates all the elements that the user engages with. It contains all the static text and defines the appearence of interactive widgets like dropdowns and sliders, as well as page layouts:\r\n\r\n\r\n# Load libraries and do other one-time tasks outside main app code.\r\n\r\nlibrary(shiny)\r\n\r\n# user interface\r\n# ui defines everything the user sees and interacts with\r\n# Fluid page organizes shiny app into rows and columns.\r\n\r\nui <- fluidPage(\r\n\r\n    )\r\n\r\n\r\n\r\nThe second fundamental element, the server, does all the background work to run the app. The “magic” of a Shiny app is reactivity, the feedback between server and ui: the user manipulates the interactive elements in the ui, then the server process user input and returns dynamic data and graphics elements. We define the server using the function(input, output), telling our app to look for inputs from objects labeled “input” and pass outputs labeled “output.”\r\n\r\n\r\n# Load libraries and do other one-time tasks outside main app code.\r\n\r\nlibrary(shiny)\r\n\r\n# user interface\r\n# ui defines everything the user sees and interacts with\r\n# Fluid page organizes shiny app into rows and columns.\r\n\r\nui <- fluidPage(\r\n\r\n    )\r\n\r\n# server is where the magic happens\r\n# all the back-end stuff\r\n# manipulating data\r\n# building reactive visuals\r\n\r\nserver <- function(input, output) {\r\n\r\n}\r\n\r\n\r\n\r\nShiny assembles the server and ui into a cohesive unit using the shinyApp() function:\r\n\r\n\r\n# Load libraries and do other one-time tasks outside main app code.\r\n\r\nlibrary(shiny)\r\n\r\n# user interface\r\n# ui defines everything the user sees and interacts with\r\n# Fluid page organizes shiny app into rows and columns.\r\n\r\nui <- shinyUI(fluidPage(\r\n\r\n      )\r\n    )\r\n\r\n# server is where the magic happens\r\n# all the back-end stuff\r\n# manipulating data\r\n# building reactive visuals\r\n\r\nserver <- function(input, output) {\r\n\r\n}\r\n\r\n# Runs the app\r\n\r\nshinyApp(ui = ui, server = server)\r\n\r\n\r\n\r\nNow that we have a handle on the basic structure of the app, let’s dive into our pine growth visualization! In each step, we will build on the previous step, until we build all the code we need to run the app.\r\nUI\r\nThe first thing we need to decide for our new app’s ui is how we want the text and visualization to be organized on the pages. Remember that Shiny apps make websites, so we have to plan out both the overall structure of the app’s pages and how they relate, as well as the layout and organization of each page. The organization of the user interface code is consequently hierarchical, with each page’s elements nested in a page layout, which is in turn nested in the whole app’s layout.\r\nWe’ll start out with a very simple layout, called a “fluidPage.” fluidPage organizes the content of our shiny app by dividing space into rows and columns that we fill with text and visualizations. There are lots of other layout options for when you’re ready to make your own apps.. We define this structure using the function fluidPage(). We’ll define the title of our page, which will show up in the top left, by typing it in quotes: \"Loblolly app\" So we’ve updated our empty shinyUI function from above to read:\r\n\r\n\r\nui <- shinyUI(fluidPage(\"Loblolly app\"\r\n\r\n      )\r\n    )\r\n\r\n\r\n\r\nNotice that we’re indenting the parentheses on seperate lines. Even though R doesn’t have semantic indenting like some other languages (i.e., R doesn’t read this any different than parentheses nested on the same line), visually breaking up our code like this can make it easier for us to read and debug later. At this point, we have a totally functional, if not very interesting, shiny app. If we click “Run App” RStudio will launch a browser window that just says “Loblolly app” in the upper left hand corner.\r\n\r\nNow let’s get rid of our “Loblolly app” sample text and add some content to our app! We’re going to use a sidebarLayout, which creates a shaded a side panel and a main panel. The side panel and main panel can both hold text, plots, maps, user input widgets, videos, and whatever else we need them to hold. The advantage of using a sidebarPanel() is that it draws the user’s eye, so it’s a great structure for communicating instructions and introductory material. Our sidepanel will hold a brief welcome for the user and a user input widget that prompts users select the age range over which they wish to visualize pine growth. We’ll also add some comments so we can remember what we were doing later. Just in case we need to say… write a tutorial explaining how to build a shiny app. One of the cool things about shiny is that you can create html outputs using a range of coding languages. We’ll use just a little bit of html here by typing br() a few times strategically to create some nice visual breaks on the page.\r\nWe’ll also add a main panel to go next to our side panel, defined using the mainPanel() function. It doesn’t have anything in it yet, which is ok. It just needs to be there so sidebarLayout() is satisfied that all its components have been accounted for. If we launch our app at this point, we should have a sidebar with a functional but so far useless slider bar.\r\n\r\n\r\nui <- fluidPage(\r\n       \r\n        # SidebarLayout creates a page with 2 panels: side and main. \r\n        \r\n        sidebarLayout(\r\n            \r\n            # sidebarPanel makes the container that holds the sidebar content\r\n            # We'll start by displaying a welcome message\r\n             \r\n            sidebarPanel(\r\n                       \"Welcome to our Loblolly Pine app!\", br(), br(),\r\n                        \"Please select the ages of pines whose\r\n                        growth you wish to view\", br(), br(),\r\n                       \r\n            # And then add our reactive element: a slider input. \r\n            # The slider controls the ages of the pines that will show up in our growth plot\r\n            # We give it a name, \"ages\" for us to pass to server\r\n            # and a name to display to the user, \"Pine Ages\"\r\n            \r\n                            sliderInput(\"ages\",\r\n                                        \"Pine Ages\", \r\n                                        min = 1, # We give the slider a minimum value\r\n                                        max = 25, # And a maximum value\r\n                                        value = 25)  # And set the default value for the slider to start at\r\n                      ),\r\n            \r\n            mainPanel(\r\n            \r\n            )\r\n        )\r\n    )\r\n\r\n\r\n\r\n\r\nServer\r\nNow that we have our user interface set up, we need some cool data products for it to display! Let’s bring back our Loblolly pine plot from earlier, but link it to the slider we built in UI so our hypothetical decision-maker can manipulate the displayed age visualization for themselves. We’ll set up our reactively updating plot using the renderPlot({}) function. Notice that renderPlot({}) uses a curly bracket nested inside the parentheses. That’s because renderPlot({}) is reactive, meaning it needs user input to function.\r\nReactivity is the ability of Shiny apps to receive user inputs and perform operations that are then returned to the user as updating visuals and values. This helps our Shiny app update only what’s needed at each step and keep its processing time reasonable. Even though we only receive the user’s input once, each time we use the information we receive from the user, it will need to be a reactive({}) value because all the values “downstream” of the user’s input depend on the value of that input. It’s generally good practice to keep our reactive values simple, so that when (not if) our code breaks, we will have an easier time identifying the problem.\r\nWe’ll use renderPlot({}) to create a plot object called pinePlot inside our output object. This will be the key we use in a moment to link server and ui together. We’re going to use renderPlot({}) to do two things: subset the data to the user’s specified date range, like we did when we first built the plot, and build the plot so we can look at it over in ui. Just like when we manually subsetted the Loblolly data into Loblolly small, we’ll keep only rows where age is less than or equal to a maximum age. We specified in ui that the user-specified maximum age is saved to an object called input$ages using the slider, so we simply swap out our static maximum age for the reactively updating value from the input$ages slider.\r\n\r\n\r\nserver <- function(input, output) {\r\n    \r\n   # Our server has one element in the output object: a plot called pinePlot    \r\n   # We create pinePlot using the renderPlot() function\r\n   # renderPlot() takes input from ui, uses it to refine the data, and \r\n   # creates the Loblolly growth plot, then passes it back to ui.\r\n    \r\n   output$pinePlot <-  renderPlot({\r\n                       \r\n   # We subset our data using the input from the slider in the side panel.            \r\n                                \r\n   LoblollySmall <- Loblolly[Loblolly$age <= input$ages,]\r\n       \r\n   # Then make our plot as before!\r\n   \r\n   plot(LoblollySmall$age, LoblollySmall$height,\r\n   xlab = \"Age (Years)\",\r\n   ylab = \"Height (Feet)\")\r\n   })\r\n}\r\n\r\n\r\n\r\nPulling it all together\r\nThe last step is to display output$pinePlot in ui. We simply use the plotOutput function to add pinePlot from the output defined by server, and there we have it, a fully functional shiny app!\r\n\r\n\r\n# Load libraries and do other one-time tasks outside main app code.\r\n\r\nlibrary(shiny)\r\n\r\n# user interface\r\n# ui defines everything the user sees and interacts with\r\n# Fluid page organizes shiny app into rows and columns.\r\n\r\n\r\nui <- fluidPage( \r\n          # SidebarLayout creates a page with 2 panels: side and main. \r\n                 \r\n                 sidebarLayout(\r\n                   \r\n                   # sidebarPanel makes the container that holds the sidebar content\r\n                   # We'll start by displaying a welcome message\r\n                   \r\n                   sidebarPanel(\r\n                     \"Welcome to our Loblolly Pine app!\", br(), br(),\r\n                     \"Please select the ages of pines whose\r\n                        growth you wish to view\", br(), br(),\r\n                     \r\n                     # And then add our reactive element: a slider input. \r\n                     # The slider controls the ages of the pines that will show up in our growth plot\r\n                     # We give it a name, \"ages\" for us to pass to server\r\n                     # and a name to display to the user, \"Pine Ages\"\r\n                     \r\n                     sliderInput(\"ages\",\r\n                                 \"Pine Ages\", \r\n                                 min = 1, # We give the slider a minimum value\r\n                                 max = 25, # And a maximum value\r\n                                 value = 25)  # And set the default value for the slider to start at\r\n                   ),\r\n                   \r\n                   mainPanel(\r\n                     \r\n                     # Display pine plot\r\n                     \r\n                     plotOutput(\"pinePlot\")\r\n                     \r\n                   )\r\n               )\r\n            )\r\n                 \r\n\r\n# server is where the magic happens\r\n# all the back-end stuff\r\n# manipulating data\r\n# building reactive visuals\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # Our server has one element in the output object: a plot called pinePlot    \r\n  # We create pinePlot using the renderPlot() function\r\n  # renderPlot() takes input from ui, uses it to refine the data, and \r\n  # creates the Loblolly growth plot, then passes it back to ui.\r\n  \r\n  output$pinePlot <-  renderPlot({\r\n    \r\n    # We subset our data using the input from the slider in the side panel.            \r\n    \r\n    LoblollySmall <- Loblolly[Loblolly$age <= input$ages,]\r\n    \r\n    # Then make our plot as before!\r\n    \r\n    plot(LoblollySmall$age, LoblollySmall$height,\r\n         xlab = \"Age (Years)\",\r\n         ylab = \"Height (Feet)\")\r\n  })\r\n}\r\n\r\n# Runs the app\r\n\r\nshinyApp(ui = ui, server = server)\r\n\r\n\r\n\r\n\r\nArticle by Lyndsie Wszola\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:14-06:00"
    },
    {
      "path": "ShinyBestPractices.html",
      "title": "Do things once: some shiny best practices",
      "author": [],
      "contents": "\r\nOur ruling strategy for engineering shiny app code will be “do things once.” Designing our apps to limit the number and types of opperations they perform will help us create fast code that conserves precious hosting time and creates an engaging user experience.\r\nOur Shiny-specific best practices flow naturally from our basic R best practices. As we discussed in our first best practices tutorial, we will endeavor to make code and outputs that are concise, well-documented, and widely accessible.\r\nOrganization and workflow\r\nJust as we considered the conceptual and visual arrangement of our code in the basic R best practices tutorial, we will now consider the conceptual and visual arrangement of the components of our shiny app. One of the best things we can do for ourselves and any future readers or users of our code is to develop a stable workflow and a robust organizational framework. Creating a defined home for source data, custom functions, images and videos, and our actual app code will help us create effective and appealing apps.\r\nFunctions\r\nAs we discussed in the functions section of our R best practices, whenever we have to do something more than once in a script or app, we should write a function to limit repetition in our code. In shiny apps, we often find ourselves needing to write several custom functions. The best way to deal with this eventuality is to place all of our functions in their own functions.R script inside the app directory and then source it in our app.\r\nData prep\r\nPreparing our data ahead of time will save us code, processing time, and headaches.\r\nCompartmentalization\r\nOrganization\r\nFunction\r\nModules\r\nPackages\r\n\r\nDo things once\r\nCompartmentalize for debugging\r\nAccessibility: tool tips, appropriate colors, no pictures of text\r\nEfficiency: prep data ahead of time\r\ncitations\r\nThe other element of accessibility we’re going to deal with is screen-reader and magnifier compatibility. Screen readers are programs used by blind and visually impaired computer users to translate text into audio. That means we need to give the screen reader something to read. Some quick screen reader tips include\r\nNo pictures of text or equations. Even if it takes more time, write it out.\r\nInclude descriptive text whenever possible. Alt text, captions, tool tips. Use it the way you write comments in your own code.\r\nAlso: no pictures of code!\r\nArticle by Lyndsie Wszola\r\n\r\n\r\n\r\n",
      "last_modified": "2021-01-30T22:41:15-06:00"
    }
  ],
  "collections": []
}
